<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Saiga</title>
        <link>http://localhost:1313/posts/</link>
        <description>所有文章 | Saiga</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>wuwenzen@outlook.com (wuwj)</managingEditor>
            <webMaster>wuwenzen@outlook.com (wuwj)</webMaster><lastBuildDate>Wed, 05 Nov 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/posts/" rel="self" type="application/rss+xml" /><item>
    <title>AI 时代的前端工程师：我的路线选择</title>
    <link>http://localhost:1313/posts/2025-11-05-career-and-ai-path/</link>
    <pubDate>Wed, 05 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-11-05-career-and-ai-path/</guid>
    <description><![CDATA[<p>过去几年，关于「前端会不会被 AI 替代」的讨论一直没停过。<br>
身边有人转去做全栈、有人转产品、有人去做大模型平台本身。</p>
<p>这篇文章不谈「行业大趋势」，只谈<strong>我自己的路线选择</strong>：<br>
在 AI 时代，作为一个长期做前端的人，我更想往哪里走？</p>
<hr>
<h2 id="1-先承认现实前端的确在变">1. 先承认现实：前端的确在变</h2>
<p>这两年有几个变化是肉眼可见的：</p>
<ol>
<li>
<p><strong>写 UI 的门槛被 AI 急剧拉低</strong></p>
<ul>
<li>设计稿转代码、自然语言生成组件、自动补齐样式</li>
<li>简单页面的实现不再是核心竞争力</li>
</ul>
</li>
<li>
<p><strong>工程复杂度在上升</strong></p>
<ul>
<li>Monorepo、模块联邦、微前端、多端一体化</li>
<li>打包、性能、可观测性、权限、配置化……这些都需要系统思考</li>
</ul>
</li>
<li>
<p><strong>AI 功能开始成为前端的一部分</strong></p>
<ul>
<li>搜索框变成「问答框」</li>
<li>表单有了「智能填写建议」</li>
<li>控制台有了「自然语言查询」</li>
</ul>
</li>
</ol>
<p>简单说：</p>
<blockquote>
<p>「会写页面」不再稀缺，<br>
「能把复杂前端系统和 AI 能力组织起来」变得更重要。</p>
</blockquote>
<hr>
<h2 id="2-给自己定一个大方向ai-时代的前端架构--体验工程">2. 给自己定一个大方向：AI 时代的「前端架构 / 体验工程」</h2>
<p>我给自己的角色定位是：</p>
<blockquote>
<p><strong>偏前端架构 + 体验工程的人，顺带能把 AI 能力合理接入。</strong></p>
</blockquote>
<p>具体来说，就是这几块能力：</p>
<ol>
<li>依然扎实的 Web / 多端前端基础</li>
<li>能从 0 到 1 搭一套前端工程体系（构建、脚手架、组件库、监控）</li>
<li>能和后端 / 算法 / 产品一起设计「AI 能力如何呈现在前端」</li>
<li>关注的是<strong>完整链路体验</strong>，而不仅仅是某一屏界面</li>
</ol>
<p>不一定非要挂一个「架构师」的 title，<br>
但思维方式更像「为整个系统体验负责的人」。</p>
<hr>
<h2 id="3-我觉得值得投入的几块技能">3. 我觉得值得投入的几块技能</h2>
<h3 id="31-系统视角的前端工程">3.1 系统视角的前端工程</h3>
<p>继续把这些东西做深：</p>
<ul>
<li>中大型项目的模块化与分层</li>
<li>Monorepo / 包管理 / 依赖治理</li>
<li>DevOps / CI / CD / 前端可观测性</li>
<li>权限、配置化、低代码能力</li>
</ul>
<p>它们和 AI 有没有关系？<br>
短期看关系不大，但长期看：</p>]]></description>
</item>
<item>
    <title>从写业务到做架构：我自己的前端方法论</title>
    <link>http://localhost:1313/posts/2025-09-20-front-end-architecture-methodology/</link>
    <pubDate>Sat, 20 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-09-20-front-end-architecture-methodology/</guid>
    <description><![CDATA[<p>做前端这几年，角色在慢慢变化：</p>
<ul>
<li>从「实现页面的人」，变成「搭框架的人」</li>
<li>从「写功能」，变成「为一整个系统的演进负责」</li>
</ul>
<p>这篇就试着把自己这几年在前端架构上的一些思路整理一下。<br>
不敢说是「最佳实践」，更像是「个人使用手册」。</p>
<hr>
<h2 id="1-架构的起点不是技术栈而是这系统要活多久">1. 架构的起点：不是技术栈，而是「这系统要活多久」</h2>
<p>每次开始新项目，我会先问三个问题：</p>
<ol>
<li>这个系统预期会存在几年？</li>
<li>未来功能是「每年一点小改」还是「不断叠加」？</li>
<li>有多少团队/多少人会长期在上面开发？</li>
</ol>
<p>举两个极端：</p>
<ul>
<li>如果只是一个活动页系统，生命周期很短，技术方案可以大胆一点嗨一点，重构成本低；</li>
<li>如果是一个核心中台系统，预期要活 5 年以上，那一开始就要考虑：模块边界、扩展点、权限体系、配置能力。</li>
</ul>
<p>所以在我这里，<strong>技术栈是一个很靠后的决策</strong>，<br>
前面更重要的是把「生命周期」和「变化模式」看清楚。</p>
<hr>
<h2 id="2-分层先把不会变的东西和经常变的东西拆开">2. 分层：先把「不会变的东西」和「经常变的东西」拆开</h2>
<p>我习惯从一个简单的三层心智模型开始：</p>
<ol>
<li>
<p><strong>基础设施层</strong></p>
<ul>
<li>构建工具、路由、状态管理、请求封装、错误处理、监控埋点</li>
<li>这些东西一旦选定，最好不要频繁更换</li>
</ul>
</li>
<li>
<p><strong>领域组件层 / 业务抽象层</strong></p>
<ul>
<li>列表页骨架、表单渲染器、查询面板、权限指令、图表组件</li>
<li>把高频但模式稳定的 UI / 交互抽象出来</li>
</ul>
</li>
<li>
<p><strong>业务编排层</strong></p>
<ul>
<li>具体的页面和流程：KYC 流程、电子合同签署、申购流程等</li>
<li>这里是需求变化最频繁的地方</li>
</ul>
</li>
</ol>
<p>核心思路是：</p>
<blockquote>
<p>把那些「经常变动的业务逻辑」，尽量放到最上层；<br>
下面两层尽量保持稳定，通过配置和扩展点来适应变化。</p>
</blockquote>
<hr>
<h2 id="3-通用组件的边界只抽重复的不强行统一一切">3. 「通用组件」的边界：只抽重复的，不强行统一一切</h2>
<p>刚开始做中台的时候，很容易掉进一个坑：</p>
<blockquote>
<p>「我要做一套能适用于所有项目的超级组件库！」</p>
</blockquote>
<p>实践下来发现，很多时候这会变成：</p>
<ul>
<li>组件越来越复杂、配置项越来越多</li>
<li>真到业务里使用时，各种 override，各种「特别 case」</li>
</ul>
<p>我现在给自己的一个约束是：</p>
<ul>
<li><strong>只有在 3 个以上业务场景里出现高度相似需求时，才考虑抽成通用组件</strong></li>
<li>抽象时优先保留可读性和可维护性，而不是极端通用</li>
</ul>
<p>举个例子：</p>
<ul>
<li>「带分页的表格 + 查询」这种，在中台项目里 100% 会反复出现，值得抽</li>
<li>某个业务特有的「图表 + 复杂交互」，就没必要强行做成「通用图表组件」</li>
</ul>
<hr>
<h2 id="4-配置化与半低代码在可控范围内偷懒">4. 配置化与「半低代码」：在可控范围内偷懒</h2>
<p>对于 B 端系统，页面很多时候是「类似但不完全一样」的：</p>
<ul>
<li>都有搜索条件、结果表格、一些按钮操作</li>
<li>但字段、条件、接口都不一样</li>
</ul>
<p>我比较认同的做法是「半低代码」：</p>]]></description>
</item>
<item>
    <title>几个 AI 小项目的复盘：什么值得长期维护</title>
    <link>http://localhost:1313/posts/2025-08-03-ai-side-project-review/</link>
    <pubDate>Sun, 03 Aug 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-08-03-ai-side-project-review/</guid>
    <description><![CDATA[<p>过去一两年，陆陆续续做了不少和 AI 相关的小项目。<br>
有些上线一两个星期就被我自己放弃，有些反而默默地用到了现在。</p>
<p>趁着空档，把这几类小项目复盘一下：</p>
<ul>
<li>哪些值得长期维护</li>
<li>哪些适合当一次性实验</li>
<li>哪些在想法层面很好，但现实里难以持续</li>
</ul>
<hr>
<h2 id="1-个人知识库--ai-搜索最常用也最值维护">1. 个人知识库 + AI 搜索：最常用，也最值维护</h2>
<h3 id="11-做了什么">1.1 做了什么</h3>
<p>这个就是前面写过的：</p>
<ul>
<li>把博客 / 笔记内容切分、向量化</li>
<li>用向量检索 + 大模型做一个「只基于自己内容」的问答</li>
</ul>
<h3 id="12-为什么一直在用">1.2 为什么一直在用？</h3>
<ol>
<li>
<p><strong>明确解决了一个长期痛点</strong></p>
<ul>
<li>「我之前好像写过这个，但忘了在哪里」</li>
<li>知识库 + AI 搜索给了一个非常直接的解法</li>
</ul>
</li>
<li>
<p><strong>需求稳定，维护成本低</strong></p>
<ul>
<li>内容只会增加，不会经常变来变去</li>
<li>系统结构相对简单，坏了问题也好排</li>
</ul>
</li>
<li>
<p><strong>使用频率高且自然</strong></p>
<ul>
<li>写新东西前想查旧文章时会用</li>
<li>工作中碰到类似问题也会顺手问一下</li>
</ul>
</li>
</ol>
<p>结论：<strong>这是那种一旦习惯了就离不开的工具，非常值得长期维护。</strong></p>
<hr>
<h2 id="2-ai-写作助手从独立产品变成一个流程中的环节">2. AI 写作助手：从独立产品变成「一个流程中的环节」</h2>
<h3 id="21-一开始怎么做的">2.1 一开始怎么做的？</h3>
<p>最早我想做一个「写作工作台」：</p>
<ul>
<li>在线编辑器 + 大纲生成 + 自动扩写</li>
<li>一键生成摘要、标签、社交媒体文案</li>
</ul>
<p>结果做着做着发现：</p>
<ul>
<li>编辑器永远写不赢现有工具（例如本地 Markdown 工具）</li>
<li>真要写东西时，我还是回到习惯的环境里去写</li>
</ul>
<h3 id="22-后来怎么调整">2.2 后来怎么调整？</h3>
<p>后来干脆把它拆散：</p>
<ul>
<li>保留「提示词模板 + 一键调用模型」部分</li>
<li>不再做自己的编辑器</li>
<li>把这些步骤融到现有写作流程里（比如借助现有工具的插件、脚本）</li>
</ul>
<h3 id="23-现在的状态">2.3 现在的状态</h3>
<p>现在的 AI 写作部分更像是：</p>
<blockquote>
<p>一些我常用的 Prompt + 一些自动脚本，散落在不同工具里。</p>]]></description>
</item>
<item>
    <title>一个「销售漏斗 &#43; AI 推荐系统」的架构草图</title>
    <link>http://localhost:1313/posts/2025-06-10-ai-sales-helper-architecture/</link>
    <pubDate>Tue, 10 Jun 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-06-10-ai-sales-helper-architecture/</guid>
    <description><![CDATA[<p>之前有个一直在脑子里打转的小项目想法：</p>
<blockquote>
<p>做一个面向 B 端业务的「销售线索 + AI 推荐」系统，
能够自动挖掘企业线索，给销售每天分配「今天优先联系谁」。</p>
</blockquote>
<p>后来花时间把这套东西从「想法」整理成了一个相对完整的架构草图。<br>
这篇就是对那张草图的文字版说明。</p>
<hr>
<h2 id="1-业务目标帮销售做三件事">1. 业务目标：帮销售做三件事</h2>
<p>先不谈技术，先看它要帮销售做什么：</p>
<ol>
<li>
<p><strong>发现客户</strong></p>
<ul>
<li>从公开网页、活动、行业名录等地方挖潜在线索</li>
<li>大致知道这些企业做什么、在哪个国家、可能需要什么服务</li>
</ul>
</li>
<li>
<p><strong>管理漏斗</strong></p>
<ul>
<li>对每一个线索标记当前阶段：
<ul>
<li>只是数据</li>
<li>已经联系</li>
<li>有意向</li>
<li>报价中</li>
<li>跟进中</li>
<li>成交 / 关闭</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>每天给行动建议</strong></p>
<ul>
<li>不让销售每天打开系统都迷茫：
<blockquote>
<p>「我今天到底该先联系谁？」</p>
</blockquote>
</li>
<li>而是自动给出一份「今日推荐线索清单」</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-总体架构从左到右看一遍">2. 总体架构：从左到右看一遍</h2>
<p>可以大致分成四层：</p>
<ol>
<li><strong>数据获取层：爬虫 / 导入 / 手工录入</strong></li>
<li><strong>数据存储与建模层：线索库 + 客户库 + 行为库</strong></li>
<li><strong>算法与 AI 层：打分、分配、推荐理由生成</strong></li>
<li><strong>展示与交互层：Web 后台 + 销售工作台</strong></li>
</ol>
<p>下面按层展开。</p>
<hr>
<h2 id="3-数据获取层信息从哪里来">3. 数据获取层：信息从哪里来？</h2>
<h3 id="31-爬虫--抓取">3.1 爬虫 / 抓取</h3>
<ul>
<li>行业展会参展企业名单</li>
<li>物流公司 / 外贸企业黄页</li>
<li>公共招投标信息</li>
<li>同行公司官网上的合作案例</li>
</ul>
<p>抓取的原则：</p>
<ul>
<li>只抓 <strong>公开网页信息</strong>，不触碰敏感或需要登录的数据</li>
<li>遵守爬虫礼仪（限速、尊重 <code>robots.txt</code> 等）</li>
<li>做基础的去重和清洗</li>
</ul>
<h3 id="32-导入--手工录入">3.2 导入 / 手工录入</h3>
<ul>
<li>销售现有 Excel、名片、线下活动名单</li>
<li>手工在系统里新增线索（比如在电话里拿到的联系方式）</li>
</ul>
<p>这些入口要做得尽量顺手，否则销售不会用。</p>]]></description>
</item>
<item>
    <title>我现在写一篇技术博客的 AI 协作流程</title>
    <link>http://localhost:1313/posts/2025-04-15-ai-assisted-writing-flow/</link>
    <pubDate>Tue, 15 Apr 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-04-15-ai-assisted-writing-flow/</guid>
    <description><![CDATA[<p>以前写一篇技术博客，经常是：</p>
<blockquote>
<p>打开编辑器 → 发呆半小时 → 终于写两段 → 忙别的去了。</p>
</blockquote>
<p>这两年逐渐把 AI 融入写作流程之后，写作变得轻松了不少。<br>
这篇就简单记录一下我现在写一篇技术文时，会怎么用 AI 来协作。</p>
<hr>
<h2 id="1-选题从零到写哪几个点">1. 选题：从零到「写哪几个点」</h2>
<p>通常起点是一个很模糊的念头，比如：</p>
<ul>
<li>「最近在搞 AI Review，好像有点东西可以写」</li>
<li>「个人知识库做完了，想记录一下实践」</li>
</ul>
<p>我会先把这个念头直接扔给 AI：</p>
<blockquote>
<p>「我想写一篇面向前端工程师的博客，主题是 XXX，对象是有 3～5 年经验的人，帮我列 5～8 个可写的角度。」</p>
</blockquote>
<p>从返回的角度里，挑 2～3 个自己最有感觉的，作为候选方向。<br>
很多时候 AI 给的那个「结构化视角」，能帮自己把脑子理顺。</p>
<hr>
<h2 id="2-大纲阶段确定文章结构而不是让-ai-代写">2. 大纲阶段：确定文章结构，而不是让 AI 代写</h2>
<p>确定方向之后，第二步才是大纲。<br>
这里我会比较主动，把自己的想法写出来：</p>
<ul>
<li>我想讲哪些实践</li>
<li>哪些坑一定要写进去</li>
<li>哪些是背景、不想展开</li>
</ul>
<p>然后让 AI 来「帮我补齐」：</p>
<blockquote>
<p>「这是我的大致大纲，你帮我看看有没有明显缺的部分，顺便按阅读顺序帮我调整一下结构。」</p>
</blockquote>
<p>AI 常给出的价值在于：</p>
<ul>
<li>提醒我「可以加一个问题背景或动机」</li>
<li>把顺序改得更平滑，比如先讲问题再讲方案</li>
</ul>
<p>但最后定稿仍然是我自己拍板。</p>
<hr>
<h2 id="3-草稿阶段辅助展开而不是从-0-到-1-代写">3. 草稿阶段：辅助展开，而不是从 0 到 1 代写</h2>
<p>大纲确定后，每一小节，我会采用一种「半手动」方式：</p>
<ol>
<li>先用要点列出我想说的内容：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>- 技术现状：目前项目里怎么做的
</span></span><span style="display:flex;"><span>- 痛点：哪些地方做起来很别扭
</span></span><span style="display:flex;"><span>- 尝试方案：试过什么，失败在哪
</span></span><span style="display:flex;"><span>- 最后采用的方案：为什么选择它
</span></span></code></pre></div><ol start="2">
<li>然后请 AI 基于要点帮我扩写成一段自然语言草稿。</li>
</ol>
<p>这样做有几个好处：</p>]]></description>
</item>
<item>
    <title>用简单推荐算法 &#43; AI 做「你可能还想看」</title>
    <link>http://localhost:1313/posts/2025-03-01-ai-recommendation-for-posts/</link>
    <pubDate>Sat, 01 Mar 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-03-01-ai-recommendation-for-posts/</guid>
    <description><![CDATA[<p>写博客时间长了，总会想：</p>
<blockquote>
<p>读完一篇文章之后，怎么自然地把读者「带」到下一篇？</p>
</blockquote>
<p>大型网站会搞一整套推荐系统、召回、排序、特征工程。<br>
个人博客没必要搞那么复杂，但做一点点「你可能还想看」，体验就会好很多。</p>
<p>这篇就记录一下我是怎么用：</p>
<ul>
<li>简单规则 + Embedding 相似度</li>
<li>再加一点点 AI 帮忙做摘要和推荐理由</li>
</ul>
<p>来实现一个轻量版推荐模块的。</p>
<hr>
<h2 id="1-推荐的目标是什么">1. 推荐的目标是什么？</h2>
<p>不是要提高 PV / UV，也没广告变现压力。</p>
<p>我给自己的目标是：</p>
<ol>
<li>让真正感兴趣的人，可以自然地看到更多相关内容</li>
<li>推荐结果有一点「懂我」的感觉，而不是随机拼凑</li>
<li>不增加太多维护成本</li>
</ol>
<p>所以技术方案尽量简单直接。</p>
<hr>
<h2 id="2-基础给每篇文章准备好向量表示">2. 基础：给每篇文章准备好「向量表示」</h2>
<p>因为之前已经做过 AI 搜索，所以每篇文章本身已经有 Embedding 了。<br>
如果你是从零开始，大致可以这么做：</p>
<ol>
<li>对每篇文章的标题 + 摘要 + 关键段落做一次 Embedding</li>
<li>把向量和文章 metadata 存进一个小库里：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsonc" data-lang="jsonc"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;slug&#34;</span>: <span style="color:#e6db74">&#34;2023-09-10-rag-for-project-docs&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;title&#34;</span>: <span style="color:#e6db74">&#34;用 RAG 做项目文档问答：从零搭一个 Demo&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;date&#34;</span>: <span style="color:#e6db74">&#34;2023-09-10&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;tags&#34;</span>: [<span style="color:#e6db74">&#34;RAG&#34;</span>, <span style="color:#e6db74">&#34;向量检索&#34;</span>],
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;vector&#34;</span>: [<span style="color:#ae81ff">0.123</span>, <span style="color:#ae81ff">-0.456</span>, <span style="color:#960050;background-color:#1e0010">...</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>后续推荐时，就可以用「向量相似度 + 标签」来组合。</p>
<hr>
<h2 id="3-推荐算法雏形规则--相似度">3. 推荐算法雏形：规则 + 相似度</h2>
<p>当用户正在阅读某一篇文章 <code>A</code> 时，我会这样选「你可能还想看」列表：</p>
<ol>
<li>
<p><strong>先做硬过滤：</strong></p>
<ul>
<li>排除 <code>A</code> 自己</li>
<li>排除未发布 / 草稿</li>
<li>若该文章属于某个年份或专题，可优先同一专题</li>
</ul>
</li>
<li>
<p><strong>基于标签做初筛：</strong></p>]]></description>
</item>
<item>
    <title>给个人网站加一个 AI 搜索框</title>
    <link>http://localhost:1313/posts/2025-01-25-ai-powered-search-on-blog/</link>
    <pubDate>Sat, 25 Jan 2025 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2025-01-25-ai-powered-search-on-blog/</guid>
    <description><![CDATA[<p>这篇算是给我自己的一份施工日志：记录我是怎么在个人网站上加一个「AI 搜索框」的。</p>
<p>目标很简单：</p>
<blockquote>
<p>让搜索不再只靠关键字，而是能用自然语言问问题，基于博客内容给出回答。</p>
</blockquote>
<p>比如：</p>
<ul>
<li>「你之前是怎么做前端性能监控的？」</li>
<li>「Monorepo 迁移里有哪些坑？」</li>
<li>「AI 和前端结合有什么实践？」</li>
</ul>
<p>都可以直接问。</p>
<hr>
<h2 id="1-先想清楚ai-搜索到底要搜什么">1. 先想清楚：AI 搜索到底要搜什么？</h2>
<p>我给自己的约束：<strong>只基于本站内容</strong>。</p>
<ul>
<li>不接入外部网络</li>
<li>不回答「全球最佳框架是哪一个」这种问题</li>
<li>只回答「我自己写过什么」「我自己是怎么想的」</li>
</ul>
<p>这样有几个好处：</p>
<ol>
<li>不用考虑太复杂的内容安全问题</li>
<li>回答的质量和风格更统一</li>
<li>搜索结果更像是「帮我找回过去的自己」</li>
</ol>
<hr>
<h2 id="2-数据准备从-hugo-的-markdown-出发">2. 数据准备：从 Hugo 的 Markdown 出发</h2>
<p>网站用的是 Hugo，文章都在 <code>content/posts</code> 中。</p>
<p>做了一个简单的数据导出脚本：</p>
<ol>
<li>遍历所有 Markdown 文件</li>
<li>解析 front matter（标题、日期、标签）</li>
<li>提取正文内容，按标题层级切分成若干小段</li>
<li>为每个小段生成一个唯一 ID + 一些元信息</li>
</ol>
<p>伪代码大概是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Chunk</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">id</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">title</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">date</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">tags</span>: <span style="color:#66d9ef">string</span>[]
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sectionPath</span>: <span style="color:#66d9ef">string</span>[]
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">content</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">url</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这些 <code>Chunk</code> 之后会被送去做向量化。</p>
<hr>
<h2 id="3-向量化与向量库把内容变成可相似度检索的形式">3. 向量化与向量库：把内容变成「可相似度检索」的形式</h2>
<h3 id="31-嵌入embedding">3.1 嵌入（Embedding）</h3>
<p>对每个片段调用 Embedding 模型，生成一个向量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">embedding</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">embed</span>(<span style="color:#a6e22e">chunk</span>.<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// embedding: number[]
</span></span></span></code></pre></div><p>向量和 metadata 一起存起来。</p>]]></description>
</item>
<item>
    <title>2024 年 AI &#43; 前端实践复盘</title>
    <link>http://localhost:1313/posts/2024-12-18-2024-ai-frontier-summary/</link>
    <pubDate>Wed, 18 Dec 2024 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2024-12-18-2024-ai-frontier-summary/</guid>
    <description><![CDATA[<p>对我来说，2024 年有一个很明显的主题：</p>
<blockquote>
<p>不再只是「尝试 AI」，而是认真把 AI 当成日常工程工具。</p>
</blockquote>
<p>这一年在 AI + 前端方向上做了几件事：</p>
<ul>
<li>表单配置助手</li>
<li>AI 参与 Code Review</li>
<li>AI 性能分析报告</li>
<li>金融前端里的风险提示与文案生成</li>
<li>Hugo + 向量库的个人知识库 + AI 搜索</li>
<li>一些配套的 CLI / 脚手架工具</li>
</ul>
<p>这篇文章算是对这一年的一个小复盘。</p>
<hr>
<h2 id="1-表单配置助手从工程抽象走向业务可用">1. 表单配置助手：从「工程抽象」走向「业务可用」</h2>
<p>之前做配置化表单，主要是为了让前端自己少写表单代码。<br>
今年把它接上大模型之后，价值有点变味了：</p>
<ul>
<li>运营/产品可以用自然语言描述表单需求</li>
<li>大模型生成表单配置草稿</li>
<li>前端做最后的结构调整和交互优化</li>
</ul>
<p>这件事让我意识到：</p>
<blockquote>
<p>以前很多工程抽象，只在前端团队内部复用；接上 AI 之后，它们可以被更多角色用起来。</p>
</blockquote>
<p>抽象层从「给自己省事」，变成了「把前端能力开放给整个团队」。</p>
<hr>
<h2 id="2-ai-参与-code-review放大镜而不是裁判">2. AI 参与 Code Review：放大镜，而不是裁判</h2>
<p>今年的另一块重点是 AI Review。</p>
<p>最后比较满意的状态是：</p>
<ul>
<li>人类 Reviewer：关注业务逻辑、架构、长期演进</li>
<li>AI Reviewer：关注边界情况、异常处理、潜在 bug</li>
</ul>
<p>如果用一个比喻：</p>
<blockquote>
<p>人类在画设计蓝图，AI 在拿放大镜看有没漏掉螺丝。</p>
</blockquote>
<p>前提是要在 Prompt 和流程上画清边界——AI 不能决定 PR 是否通过，只能给建议。</p>
<hr>
<h2 id="3-ai-性能分析报告减少翻译工作">3. AI 性能分析报告：减少「翻译工作」</h2>
<p>性能优化里最花时间的一件事，是把那些指标和图表翻译成所有人都看得懂的报告。</p>
<p>今年做的 AI 性能报告本质上就是：</p>]]></description>
</item>
<item>
    <title>维护一套「金融级」系统的日常：技术债与治理</title>
    <link>http://localhost:1313/posts/2024-11-05-financial-system-governance/</link>
    <pubDate>Tue, 05 Nov 2024 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2024-11-05-financial-system-governance/</guid>
    <description><![CDATA[<p>说起「金融级系统」，大家容易想到的是：</p>
<ul>
<li>高并发</li>
<li>高可用</li>
<li>高安全</li>
</ul>
<p>但在真实的日常里，还有一个很现实的关键词：<strong>高技术债</strong>。</p>
<ul>
<li>业务历史长、变更多</li>
<li>合规要求频繁更新</li>
<li>很多模块不能随便重写</li>
</ul>
<p>这篇文章就从比较接地气的角度聊聊：<br>
在这样的系统里，技术债和日常治理是怎么做的。</p>
<hr>
<h2 id="1-金融场景里的特殊约束">1. 金融场景里的特殊约束</h2>
<p>与普通业务系统相比，金融场景多了几重约束：</p>
<ol>
<li>
<p><strong>改动窗口有限</strong></p>
<ul>
<li>很多系统几乎 7x24 对外服务</li>
<li>大规模重构很难找到合适时间</li>
</ul>
</li>
<li>
<p><strong>变更必须可追溯</strong></p>
<ul>
<li>每次上线要有需求单、评审记录、上线记录</li>
<li>问题追踪时需要知道「谁在什么时候改了什么」</li>
</ul>
</li>
<li>
<p><strong>合规优先级很高</strong></p>
<ul>
<li>有些地方技术上可以更「聪明」，但监管不允许</li>
<li>文案、交互、流程都要满足监管要求</li>
</ul>
</li>
</ol>
<p>在这样的前提下，治理技术债更像「做长期的小手术」，而不是一刀重构。</p>
<hr>
<h2 id="2-技术债分类先搞清楚你在还什么债">2. 技术债分类：先搞清楚你在还什么债</h2>
<p>简单分几类：</p>
<ol>
<li>
<p><strong>架构层</strong></p>
<ul>
<li>模块边界不清晰、耦合严重</li>
<li>某几个服务成为「超级大脑」，什么都往里堆</li>
</ul>
</li>
<li>
<p><strong>代码实现层</strong></p>
<ul>
<li>大量 if-else、魔法数字、历史兼容逻辑堆在一起</li>
<li>几乎没有单测，修改时心里没底</li>
</ul>
</li>
<li>
<p><strong>数据 / 配置层</strong></p>
<ul>
<li>配置散落在代码、数据库、Excel 里</li>
<li>不同环境的配置差异无法一眼看清</li>
</ul>
</li>
<li>
<p><strong>流程与文档层</strong></p>
<ul>
<li>变更流程不统一</li>
<li>重要模块靠「口口相传」交接</li>
</ul>
</li>
</ol>
<p>不同类型的债，解决策略完全不同，不可能靠「重构一次解决一切」。</p>
<hr>
<h2 id="3-三个抓手缺陷变更性能">3. 三个抓手：缺陷、变更、性能</h2>
<p>不做大手术的前提下，日常治理主要围绕三件事：</p>
<h3 id="31-缺陷闭环">3.1 缺陷闭环</h3>
<ul>
<li>给线上问题做<strong>原因分类</strong>：
<ul>
<li>需求理解偏差</li>
<li>边界条件缺失</li>
<li>环境差异</li>
<li>历史逻辑冲突</li>
</ul>
</li>
<li>对高频类别做专项治理：比如「配置错误类问题」集中爆发，就推动配置平台化</li>
</ul>
<h3 id="32-变更管理">3.2 变更管理</h3>
<ul>
<li>对高风险模块设置更严格的审批和回归要求</li>
<li>把「问题最多的改动类型」可视化：
<ul>
<li>是谁频繁动核心配置？</li>
<li>是不是某类「紧急需求」总是容易出错？</li>
</ul>
</li>
</ul>
<h3 id="33-性能监控">3.3 性能监控</h3>
<ul>
<li>对关键接口/页面设定性能基线</li>
<li>一旦持续劣化，触发专项排查</li>
<li>配合前面说的 AI 性能报告，让「性能」成为团队常规话题</li>
</ul>
<hr>
<h2 id="4-一个例子报表模块的小范围治理">4. 一个例子：报表模块的小范围治理</h2>
<p>以一个典型的报表模块为例：</p>]]></description>
</item>
<item>
    <title>写几个小脚本帮自己省时间：前端 CLI / 脚手架实践</title>
    <link>http://localhost:1313/posts/2024-09-28-cli-and-scaffolding-tools/</link>
    <pubDate>Sat, 28 Sep 2024 00:00:00 &#43;0000</pubDate>
    <author>wuwj</author>
    <guid>http://localhost:1313/posts/2024-09-28-cli-and-scaffolding-tools/</guid>
    <description><![CDATA[<p>有段时间我发现自己经常在做几件很机械的事：</p>
<ul>
<li>新建一个页面：建目录、复制模板、改标题、改路由</li>
<li>加一个接口：建 service 文件、写类型、写请求封装</li>
<li>搭一个模块：列表页 + 详情页 + 编辑页，一遍遍重复</li>
</ul>
<p>于是索性写了一组小 CLI 工具，把这些动作变成命令行：</p>
<blockquote>
<p><code>npx fe-tools create-page</code><br>
<code>npx fe-tools create-api</code><br>
<code>npx fe-tools create-module</code></p>
</blockquote>
<p>这篇文章就简单记录一下这几个脚本的思路。</p>
<hr>
<h2 id="1-create-page新页面一条命令">1. <code>create-page</code>：新页面一条命令</h2>
<p>很多中台项目新增页面的套路都差不多：</p>
<ol>
<li>在 <code>views</code> 下建目录</li>
<li>填一个基础骨架组件</li>
<li>在路由里挂载</li>
<li>有的还要加到菜单配置里</li>
</ol>
<p>用 Node.js 写了一个 <code>create-page</code> 命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>npx fe-tools create-page
</span></span></code></pre></div><p>命令执行后，做几件事：</p>
<ol>
<li>
<p>命令行交互询问：</p>
<ul>
<li>页面英文名（路由 path）</li>
<li>页面中文标题</li>
<li>页面类型：列表 / 表单 / 详情 / 组合</li>
</ul>
</li>
<li>
<p>基于模板生成对应文件，例如：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-vue" data-lang="vue"><span style="display:flex;"><span>&lt;<span style="color:#f92672">template</span>&gt;
</span></span><span style="display:flex;"><span>  &lt;<span style="color:#f92672">PageWrapper</span> <span style="color:#a6e22e">title</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;投资人概览&#34;</span>&gt;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--</span> <span style="color:#a6e22e">TODO</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">填充页面内容</span> <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span>  &lt;/<span style="color:#f92672">PageWrapper</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">template</span>&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">setup</span> <span style="color:#a6e22e">lang</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ts&#34;</span>&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 预留接口调用和状态管理位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>&lt;/<span style="color:#f92672">script</span>&gt;
</span></span></code></pre></div><ol start="3">
<li>自动往某个路由模块里追加配置</li>
</ol>
<p>这样新页面出现的那一刻就已经可以访问，只需要填内容。</p>
<hr>
<h2 id="2-create-api接口封装生成器">2. <code>create-api</code>：接口封装生成器</h2>
<p>写接口封装时经常要做：</p>]]></description>
</item>
</channel>
</rss>
