<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>缓存 on Saiga</title>
    <link>http://localhost:1313/tags/%E7%BC%93%E5%AD%98/</link>
    <description>Recent content in 缓存 on Saiga</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <managingEditor>wuwenzen@outlook.com (wuwj)</managingEditor>
    <webMaster>wuwenzen@outlook.com (wuwj)</webMaster>
    <lastBuildDate>Thu, 14 Jul 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一次性能优化实战：从 5s 到 1.5s 的页面加载</title>
      <link>http://localhost:1313/posts/2022-07-14-performance-optimization-case/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate><author>wuwenzen@outlook.com (wuwj)</author>
      <guid>http://localhost:1313/posts/2022-07-14-performance-optimization-case/</guid>
      <description>&lt;p&gt;有一次线上迭代后，陆续收到反馈：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;「系统能用，就是打开慢了一截。」&lt;br&gt;&#xA;「首页白屏时间变长了。」&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;监控一看，某个核心页面的首屏时间从 &lt;strong&gt;约 2s 抬升到了接近 5s&lt;/strong&gt;。&lt;br&gt;&#xA;这篇文章就是那次性能优化的实战复盘：&lt;strong&gt;我们如何量化问题、定位瓶颈、再一步步把首屏拉回到 1.5s 左右。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-先量化而不是拍脑袋&#34;&gt;1. 先量化，而不是拍脑袋&lt;/h2&gt;&#xA;&lt;p&gt;第一步是搞清楚「慢」在哪：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首包下载？&lt;/li&gt;&#xA;&lt;li&gt;JS 执行？&lt;/li&gt;&#xA;&lt;li&gt;接口耗时？&lt;/li&gt;&#xA;&lt;li&gt;还是一堆「非必要逻辑」抢在首屏执行？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我们主要用了三种手段：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Chrome DevTools Performance&lt;/strong&gt; 看关键时序；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lighthouse&lt;/strong&gt; 跑实验室指标；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;前端埋点&lt;/strong&gt; 看真实用户数据（FMP/TTI 的简化近似）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;初步结论：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JS 资源总体体积较大，首屏要加载的 JS 超过 1MB（压缩后）；&lt;/li&gt;&#xA;&lt;li&gt;首屏渲染完成前存在一段较长的 JS 执行（主线程被占用）；&lt;/li&gt;&#xA;&lt;li&gt;首屏接口本身不是特别慢，但被一些&lt;strong&gt;不必要的请求&lt;/strong&gt;夹在中间。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;目标明确：&lt;strong&gt;瘦 JS、少阻塞、分优先级。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-bundle-拆分让首屏只拿它真需要的&#34;&gt;2. Bundle 拆分：让首屏只拿它真需要的&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-分析构建结果&#34;&gt;2.1 分析构建结果&lt;/h3&gt;&#xA;&lt;p&gt;接入 &lt;code&gt;webpack-bundle-analyzer&lt;/code&gt; / Vite 插件之后，很快看到几个「大头」：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整个 UI 组件库全量引入；&lt;/li&gt;&#xA;&lt;li&gt;某些图表库（在其他页面才用）被打进首屏 bundle；&lt;/li&gt;&#xA;&lt;li&gt;若干工具库重复/未 Tree-shaking。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;22-做的调整&#34;&gt;2.2 做的调整&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;组件库改为按需引入&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把 &lt;code&gt;import ElementUI from &#39;element-ui&#39;&lt;/code&gt; 改成 babel 插件/手动按需；&lt;/li&gt;&#xA;&lt;li&gt;打包结果里组件库体积明显下降。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;路由级别代码拆分&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
