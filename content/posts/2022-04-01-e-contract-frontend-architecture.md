+++
title = "电子合同前端架构：模版、签章与签署流程"
date = 2022-04-01
draft = false
categories = ["金融前端", "架构设计"]
tags = ["电子合同", "前端架构", "签章", "模版管理"]
description = "结合实际项目拆解电子合同前端：如何把合同模版管理、渲染引擎、签章交互和签署流程拆开设计，既满足合规留痕，又兼顾扩展性。"
+++

做电子合同相关的前端，会很快感觉到：

- 这已经不只是「展示一个 PDF」；  
- 还牵扯到模版配置、变量渲染、签章交互、签署流程编排、证据留存等。  

如果一股脑儿堆在一个项目里，很快就会失控。  
这篇文章试着从前端视角，把电子合同拆成几个独立模块，聊聊一套比较清晰的架构思路。

---

## 1. 电子合同前端要解决什么？

从用户视角看，大概是：

1. 看到合同预览（包含自己信息）；  
2. 在指定位置签名/盖章/确认；  
3. 提交后能下载已签署版本，必要时可验证真伪。  

从前端视角再拆细一点：

- **模版管理**：合同模版如何配置 & 渲染；  
- **变量填充**：客户姓名、证件号、金额等动态内容；  
- **渲染方式**：HTML 还是 PDF 预览，是否支持高缩放；  
- **签章交互**：点击签署区域、手写签名/用预制印章；  
- **流程编排**：签署顺序、多人会签/联签；  
- **留痕 & 防篡改**：前端如何配合后端做证据链。  

这些职责千万别写在一个「超级组件」里。

---

## 2. 模块切分：四层结构

我们落地时，大致划成四层：

```text
业务流程层  ←  电子合同服务层  ←  渲染 & 交互层  ←  基础组件 & 工具层
```

### 2.1 业务流程层（具体业务系统）

例如：开户流程、理财签约、风险揭示等业务系统：

- 只关心「在流程某一环节触发合同签署」；  
- 不直接操心合同模版、签章细节；  
- 与电子合同前端交互的接口尽量保持简单。

### 2.2 电子合同服务层（前端 SDK）

可以理解成一个前端 SDK：

- 提供统一方法：`createContract`, `previewContract`, `signContract`；  
- 内部负责：请求合同服务接口、拿到模版、变量、签署状态等；  
- 把渲染和交互细节屏蔽在内部。

示例：

```ts
import { openContractSignDialog } from '@ecm/sdk';

await openContractSignDialog({
  bizType: 'OPEN_ACCOUNT',
  bizId: 'xxx',
  viewer: 'customer',
});
```

### 2.3 渲染 & 交互层

- 负责把合同模版 + 变量渲染成可阅读界面；  
- 在指定签署域上挂载交互（点击弹签名板等）；  
- 处理缩放、翻页、跳转签署域等体验细节。

### 2.4 基础组件 & 工具层

- PDF/HTML 渲染组件；  
- 手写签名板组件；  
- 坐标转换、缩放计算工具；  
- 与后端约定的签署域结构解析等。

---

## 3. 合同模版与变量渲染

### 3.1 模版形式

常见两种：

1. **HTML 模版**  
   - 后端/运营维护 HTML + 占位符（如 `{{customerName}}`）；  
   - 前端拿到后直接渲染成 DOM。  

2. **PDF 模版 + 变量覆盖**  
   - 合同是固定 PDF，变量字段由另外的结构描述位置；  
   - 前端用 PDF 预览组件叠加文字层。  

我们项目里两种都遇到过，因而在前端做了一个「模版适配层」。

### 3.2 变量渲染接口约定

后端一般会返回：

```json
{
  "templateType": "HTML",
  "templateContent": "<html>......{{customerName}}...</html>",
  "data": {
    "customerName": "张三",
    "idNo": "440***********"
  }
}
```

或：

```json
{
  "templateType": "PDF",
  "pdfUrl": "https://.../template.pdf",
  "textOverlays": [
    {
      "key": "customerName",
      "value": "张三",
      "page": 1,
      "x": 120,
      "y": 230
    }
  ]
}
```

前端根据 `templateType` 分发到不同渲染组件：

```ts
if (templateType === 'HTML') {
  renderHtmlTemplate(templateContent, data);
} else {
  renderPdfTemplate(pdfUrl, textOverlays);
}
```

HTML 情况下可以用简单的模版引擎，例如 Mustache / Handlebars 或自研替换。  
PDF 情况下则在 Canvas / SVG / DOM 之上叠文字。

---

## 4. 签章交互：签署域、手写签名与印章

关键是统一「签署域」的模型：

```ts
interface SignField {
  id: string;
  page: number;
  x: number;
  y: number;
  width: number;
  height: number;
  signerType: 'CUSTOMER' | 'ORG' | 'OPERATOR';
  status: 'PENDING' | 'SIGNED';
}
```

后端在模版里事先配置好签署域，前端拿到这组数据后：

1. 在渲染层按坐标画出一个透明点击区域；  
2. 用户点击后：  
   - 如果是客户手写签名：弹出签名板；  
   - 如果是机构公章：走后端自动盖章流程（前端只展示结果）。  

### 4.1 手写签名板

- Canvas 或 SVG 实现；  
- 支持清除、重签；  
- 输出为图片（PNG）或向量数据。  

前端把签名图片上传到后端，由后端负责：

- 与模版合成；  
- 入库存证；  
- 生成最终文件。

### 4.2 多方签署与状态同步

在多人会签场景下：

- 前端通过轮询 / WebSocket 获取当前合同签署状态；  
- 对不同 signer 看到的界面略有差异（只能签自己的那一块）；  
- 状态条显示「待甲方签署 / 待乙方签署 / 已完成」。

---

## 5. 签署流程：从「打开合同」到「签署完成」

我们通常会把签署流程封装成一个「对话框」或「全屏页」，大致步骤：

1. 拉取合同详情：模版 + 变量 + 签署域 + 状态；  
2. 渲染预览，标出当前用户需要签的区域；  
3. 用户点击签署域 → 完成签名/确认 → 回写状态；  
4. 所有需要签署的都完成后，调用「确认完成」接口；  
5. 返回下载链接/查看已签署版本入口。

期间注意：

- 每次签署操作最好有「本地态」反馈（比如域上显示一个 ✓）；  
- 即便「确认完成」接口失败，也要保证已完成签名不会丢（操作具有幂等性）；  
- 对手机端/小屏场景做适配，避免签署区域太小点不中。

---

## 6. 合规与可追溯：前端能做什么？

合规和证据链主要还是后端/第三方存证平台负责，但前端可以配合：

1. 在关键操作时携带：设备信息、IP、大致地理位置（如有）、浏览器 UA；  
2. 在签署过程中避免刷新/后退导致状态混乱，必要时给出明确提示；  
3. 把一些风险提示、确认文案做成不可绕过的步骤，并在接口里带上「勾选记录」。

例如：

```ts
await api.confirmRiskNotice({
  contractId,
  checkedAt: Date.now(),
  userAgent: navigator.userAgent,
});
```

---

## 7. 总结

电子合同前端如果不刻意做拆分，很容易变成一个**巨大而混乱的模块**。  
更清晰的方式是：

1. 用「前端 SDK」形式对业务方暴露简单接口；  
2. 内部拆分：模版渲染、签章交互、流程编排几个子模块；  
3. 约定好模版结构、变量渲染和签署域模型，让前后端有清晰契约；  
4. 在交互层处理好缩放、点击区域、签名板体验；  
5. 充分配合合规方做证据留痕。  

这样，无论以后新增多少业务场景（开户、赎回、风险揭示…），都可以复用同一套电子合同能力，而不是在每个系统里重复造轮子。

